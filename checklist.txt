# CHECKLIST PROJET PUSH_SWAP

### 0. PRÉPARATION & CONCEPTS
[x] Lire le sujet en entier (vraiment tout).
[x] Se renseigner sur : La structure de données "Pile" (Stack).
[ ] Se renseigner sur : Les listes chaînées (Linked Lists) vs Tableaux (Arrays).
    -> Note : Les listes chaînées sont souvent préférées ici
	pour manipuler les piles sans réallouer de mémoire constamment.
[x] Se renseigner sur : La complexité algorithmique (Big O Notation).
[ ] Se renseigner sur : Les algorithmes de tri existants 
(Radix sort, Quick sort, insertion sort).
[ ] Se renseigner sur : La représentation binaire des entiers
(utile si tu choisis un Radix sort).

### 1. STRUCTURE DU PROJET (Squelette)
[ ] Créer le dépôt Git et l'arborescence des fichiers.
[ ] Créer le Makefile.
    [ ] Règle $(NAME)
    [ ] Règle all
    [ ] Règle clean
    [ ] Règle fclean
    [ ] Règle re
    [ ] Vérifier qu'il ne "relink" pas inutilement.
[ ] Inclure la Libft (si tu décides de l'utiliser) et faire fonctionner
le Makefile avec.
[ ] Créer un fichier header (.h) pour tes structures et prototypes.

### 2. PARSING (Gestion des arguments)
[ ] Se renseigner sur : La fonction `atoi` ou `atol` (conversion chaîne vers entier).
[ ] Coder la récupération des arguments (argv).
    [ ] Gérer le cas : nombres passés en plusieurs arguments ("./push_swap 1 2 3").
    [ ] Gérer le cas : nombres passés en une seule chaîne ("./push_swap '1 2 3'").
[ ] Coder la vérification des erreurs (Doit afficher "Error\n" sur la sortie 
d'erreur standard 2).
    [ ] Vérifier si un argument n'est pas un nombre.
    [ ] Vérifier si un nombre dépasse MAX_INT ou MIN_INT.
    [ ] Vérifier s'il y a des doublons dans la liste.
[ ] Stocker les nombres validés dans la structure de données choisie (Stack A).

### 3. LES MOUVEMENTS (Le moteur)
[ ] Coder les fonctions de base (primitives).
    [ ] swap (sa, sb, ss) : Échanger les deux premiers éléments.
    [ ] push (pa, pb) : Envoyer le premier élément d'une pile sur l'autre.
    [ ] rotate (ra, rb, rr) : Le premier devient le dernier.
    [ ] reverse rotate (rra, rrb, rrr) : Le dernier devient le premier.
[ ] Tester CHAQUE mouvement individuellement pour être sûr qu'ils ne perdent 
pas de mémoire et déplacent bien les maillons.

### 4. ALGORITHME SIMPLE (Hardcoding)
[ ] Gérer le cas : 2 nombres (si pas triés, juste un swap).
[ ] Gérer le cas : 3 nombres.
    [ ] Se renseigner sur : Les permutations possibles de 3 nombres 
	(il n'y en a que 5 cas non triés possibles).
    [ ] Coder une fonction spécifique qui trie 3 nombres en moins de 3 coups.

### 5. ALGORITHME MOYEN (4 et 5 nombres)
[ ] Créer une logique pour 4 et 5 nombres.
    [ ] Stratégie classique : Pousser le plus petit nombre vers la Stack B, 
	trier les 3 restants dans A (avec l'algo précédent), puis faire revenir 
	le nombre de B.

### 6. ALGORITHME COMPLEXE (100 et 500 nombres)
[ ] Se renseigner sur : Les algorithmes de coût (Cost algorithm) ou le "Turk Algorithm"
(très populaire pour ce projet).
    ou
[ ] Se renseigner sur : Le tri par base (Radix Sort) si tu es à l'aise avec le binaire.
[ ] Choisir une stratégie :
    [ ] Découper les nombres en "chunks" (paquets) pour les envoyer dans B ?
    [ ] Ou calculer le "coût" de déplacement de chaque nombre pour 
	choisir le moins cher à bouger ?
[ ] Implémenter l'algorithme choisi.

### 7. OPTIMISATION & DEBUG
[ ] Créer ou télécharger un script de test (tester avec des valeurs aléatoires).
[ ] Vérifier les performances (nombre de coups) :
    [ ] 100 nombres : Objectif < 700 opérations.
    [ ] 500 nombres : Objectif < 5500 opérations.
[ ] Vérifier les fuites de mémoire (Valgrind).
[ ] Norminette (Vérifier tout le code).

### 8. DOCUMENTATION (Obligatoire)
[ ] Rédiger le README.md à la racine.
    [ ] Description du projet.
    [ ] Instructions de compilation et d'exécution.
    [ ] Ressources et crédits.

### 9. BONUS (Optionnel - Seulement si le reste est parfait)
[ ] Coder le programme `checker`.
    [ ] Il doit lire les instructions sur l'entrée standard (stdin).
    [ ] Il doit exécuter les mouvements sur les piles.
    [ ] Il doit afficher "OK" si trié, "KO" sinon.